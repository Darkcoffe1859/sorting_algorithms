This project involves the sorting Algorithms
sorting algorithms are algorithms that arrange elements in a specific order, such as ascending or descending, based on a defined comparison criteria. There are various sorting algorithms, each with its own characteristics and time complexities. Here are some commonly used sorting algorithms:

Bubble Sort: It repeatedly compares adjacent elements and swaps them if they are in the wrong order until the entire list is sorted. It has a worst-case and average-case time complexity of O(n^2).

Selection Sort: It repeatedly finds the minimum element from the unsorted part of the list and places it at the beginning. It has a worst-case and average-case time complexity of O(n^2).

Insertion Sort: It builds the final sorted array one element at a time by inserting each element into its correct position within the already sorted part of the array. It has a worst-case and average-case time complexity of O(n^2).

Merge Sort: It follows the divide-and-conquer approach by recursively dividing the list into smaller sublists, sorting them, and then merging them back together to obtain the final sorted list. It has a time complexity of O(n log(n)) in all cases.

Quick Sort: It also follows the divide-and-conquer approach and uses a pivot element to partition the list into two sublists, one with elements smaller than the pivot and the other with elements greater than the pivot. It recursively applies this process to the sublists until the entire list is sorted. It has an average-case time complexity of O(n log(n)), but its worst-case time complexity is O(n^2).

Heap Sort: It builds a max-heap or min-heap data structure from the list and then repeatedly extracts the root element to obtain the sorted list. It has a time complexity of O(n log(n)) in all cases.

Radix Sort: It sorts elements by processing them based on their digits or individual characters. It can achieve linear time complexity, specifically O(k * n), where k is the maximum number of digits or characters.

